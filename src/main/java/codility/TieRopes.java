package codility;

public class TieRopes {

  public int solution(int K, int[] A) {
    // write your code in Java SE 8
    int result = 0;
    int length = 0;
    for (int rope : A) {
      length += rope;
      if (length >= K) {
        result++;
        length = 0;
      }
    }
    return result;
  }

  public static void main(String[] args) {
    TieRopes tr = new TieRopes();
    System.out.println(tr.solution(4, new int[] {1, 2, 3, 4, 1, 1, 3}));
  }

  /**
   * 0에서 N − 1까지 번호가 매겨진 N개의 로프가 있고, 그 길이는 A 배열로 되어 있으며 바닥에 일렬로 놓여 있습니다. 각 I(0 ≤ I < N)에 대해 줄에 있는 로프 I의 길이는 A[I]입니다.
   *
   * 우리는 두 개의 로프 I와 I + 1이 인접해 있다고 말합니다. 두 개의 인접한 로프를 매듭으로 묶을 수 있으며 묶인 로프의 길이는 두 로프의 길이의 합입니다. 그 결과 새로운 로프를 다시 묶을 수 있습니다.
   *
   * 주어진 정수 K에 대해 목표는 길이가 K보다 크거나 같은 로프의 수가 최대가 되도록 로프를 묶는 것입니다.
   *
   * 예를 들어 다음과 같은 K = 4 및 배열 A를 고려합니다.
   *
   *     A[0] = 1
   *     A[1] = 2
   *     A[2] = 3
   *     A[3] = 4
   *     A[4] = 1
   *     A[5] = 1
   *     A[6] = 3
   * 로프는 아래 그림과 같습니다.
   *
   *
   *
   * 우리는 묶을 수 있습니다:
   *
   * 길이 A[1] + A[2] = 5인 로프를 생성하기 위해 로프 2와 로프 1;
   * 길이 A[4] + A[5] + A[6] = 5의 로프를 생성하기 위해 로프 4와 로프 5와 로프 6.
   * 그 후, 길이가 K = 4보다 크거나 같은 3개의 로프가 있을 것입니다. 그러한 로프 4개를 생산하는 것은 불가능합니다.
   *
   * 함수 작성:
   *
   * 클래스 솔루션 { 공개 int 솔루션(int K, int[] A); }
   *
   * 정수 K와 N 정수의 비어 있지 않은 배열 A가 주어지면 생성할 수 있는 K보다 크거나 같은 길이의 로프의 최대 수를 반환합니다.
   *
   * 예를 들어, 주어진 K = 4 및 배열 A는 다음과 같습니다.
   *
   *     A[0] = 1
   *     A[1] = 2
   *     A[2] = 3
   *     A[3] = 4
   *     A[4] = 1
   *     A[5] = 1
   *     A[6] = 3
   * 함수는 위에서 설명한 대로 3을 반환해야 합니다.
   *
   * 다음 가정에 대한 효율적인 알고리즘을 작성하십시오.
   *
   * N은 [1..100,000] 범위 내의 정수입니다.
   * K는 [1..1,000,000,000] 범위 내의 정수입니다.
   * 배열 A의 각 요소는 [1..1,000,000,000] 범위 내의 정수입니다.
   */
}
